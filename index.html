<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Muncher - Farcaster</title>

    <!-- 1. Tailwind (Design) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Farcaster Embed Metadata & Open Graph -->
    <meta name="fc:miniapp" content='{
      "version":"next",
      "imageUrl":"https://<YOUR_APP_URL>/pixel-muncher-embed.png", 
      "button":{
          "title":"Play Pixel Muncher!",
          "action":{
          "type":"launch_miniapp",
          "name":"Pixel Muncher",
          "url":"https://https://pixel-coral-theta.vercel.app/" 
          }
      },
      "castShareUrl": "https://<YOUR_APP_URL>", 
      "ogTitle": "Pixel Muncher - Mini App", 
      "ogDescription": "Classic arcade munching fun!", 
      "ogImageUrl": "https://<YOUR_APP_URL>/pixel-muncher-embed.png" 
    }' />

    <!-- 3. React -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
            overflow: hidden; /* Hide scrollbars */
            color: #e7ecf0;
        }
        canvas {
            background-color: #000;
            border: 4px solid #374151; /* gray-700 */
            border-radius: 8px;
            display: block; /* Remove extra space below canvas */
            touch-action: none; /* Disable default touch actions */
        }
        .arcade-header {
            background: linear-gradient(90deg, rgba(250, 204, 21, 1) 0%, rgba(236, 72, 153, 1) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .game-button {
            transition: all 0.3s ease;
        }
        .game-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);
        }
        .modal {
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex; /* Use flex for centering */
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #1F2937; /* bg-gray-800 */
            padding: 24px;
            border-radius: 12px;
            border: 1px solid #4B5563; /* bg-gray-600 */
            width: 90%;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }
         /* Simple glow effect for buttons */
        .primary-button {
             padding:14px 28px; background:linear-gradient(135deg,#ff8c42,#ff6b1a); color:#fff; border:none; border-radius:12px; font-weight:900; font-size:16px; cursor:pointer; box-shadow:0 6px 20px rgba(255,107,26,0.4); transition:all .2s; text-transform:uppercase; letter-spacing:.5px; 
        }
         .primary-button:hover:not(:disabled){ transform:translateY(-2px); box-shadow:0 8px 25px rgba(255,107,26,.5); }
         .primary-button:disabled{ opacity:.6; cursor:not-allowed; }

         .secondary-button{ padding:12px 24px; background:linear-gradient(135deg,#38bdf8,#34d399); color:#0a1929; border:none; border-radius:10px; font-weight:900; font-size:14px; cursor:pointer; box-shadow:0 4px 15px rgba(56,189,248,.3); transition:all .2s; letter-spacing:.5px; text-transform:uppercase; }
          .secondary-button:hover:not(:disabled){ transform:translateY(-2px); }
         .secondary-button:disabled{ opacity:.6; cursor:not-allowed; }
         
         /* Background overlay for better text readability on home */
        .home-overlay::before {
            content: "";
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(17, 24, 39, 0.7); /* bg-gray-900 with opacity */
            z-index: 1; /* Place overlay below content */
        }
        .home-content {
             position: relative; /* Ensure content is above overlay */
             z-index: 2;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center p-2 sm:p-4">
    <div id="root"></div>

    <script type="module">
        // ========= 1. Import SDK & Call Ready =========
        import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
        sdk.actions.ready();
        console.log("Farcaster SDK ready() called immediately.");

        // ========= 2. React Setup & Helpers =========
        const { useState, useEffect, createElement, useRef, useCallback } = React;

        function parseEther(x) {
            const [w, f = ""] = String(x).split('.');
            const frac = (f + '0'.repeat(18)).slice(0, 18);
            return '0x' + (BigInt(w) * 10n ** 18n + BigInt(frac)).toString(16);
        }

        async function getProvider() {
            try {
                console.log("Attempting to get provider via sdk.wallet.getEthereumProvider()");
                const p = await sdk.wallet.getEthereumProvider();
                if (p) {
                    console.log("Farcaster provider found:", p);
                    return p;
                }
            } catch (e) {
                console.warn("Error getting Farcaster provider, falling back to window.ethereum", e);
            }
            console.log("Farcaster provider not found, checking window.ethereum");
            if (window.ethereum) {
                console.log("window.ethereum found:", window.ethereum);
                return window.ethereum;
            }
            console.log("No provider found.");
            return null;
        }

        // ========= 3. Game Constants & Config =========
        const gridSize = 20;
        const GAME_FEE_ETH = '0.00001'; // Fee l kol match
        const DEVELOPER_WALLET = '0x0e315015A4eE8d5D6c4b43E300dF76b965D55bDd'; // <--- BDDL HADI B L'ADRESSE DYALK!
        const ROUND_TIME = 60; // Wakht dyal round (ila bghinah) - Not used in Pac-Man yet
        const MAX_LIVES = 3;

        // --- Maps Data ---
        const map1 = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,2,1],
            [1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,0,1],
            [1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1],
            [1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1],
            [1,0,1,1,0,1,3,3,3,3,3,3,3,3,3,1,0,1,1,0,1],
            [1,0,1,1,0,1,3,1,1,1,1,1,1,1,3,1,0,1,1,0,1],
            [1,0,0,0,0,1,3,1,3,3,3,3,3,1,3,1,0,0,0,0,1],
            [1,1,1,1,0,1,3,1,3,3,3,3,3,1,3,1,0,1,1,1,1],
            [3,3,3,1,0,1,3,1,1,1,1,1,1,1,3,1,0,1,3,3,3], // Tunnel row
            [1,1,1,1,0,1,3,3,3,3,3,3,3,3,3,1,0,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,0,1],
            [1,0,1,1,0,0,0,0,0,0,3,0,0,0,0,0,0,1,1,0,1], // Empty cell fl wst
            [1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1],
            [1,0,1,1,1,1,0,0,0,0,1,0,0,0,0,1,1,1,1,0,1],
            [1,2,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        const allMaps = [ 
            { 
              map: map1, 
              playerStart: { x: 10, y: 13 }, 
              ghostStart: [
                  { x: 10, y: 7, color: '#EF4444', mode: 'direct'}, // Red (Blinky)
                  { x: 9, y: 8, color: '#F472B6', mode: 'ambush'}, // Pink (Pinky)
                  { x: 10, y: 8, color: '#22D3EE', mode: 'direct'}, // Cyan (Inky)
                  { x: 11, y: 8, color: '#F97316', mode: 'random'} // Orange (Clyde)
              ],
              ghostBoxExit: { x: 10, y: 7 } 
            }
        ];
        const currentMapData = allMaps[0]; 
        const mapWidth = currentMapData.map[0].length;
        const mapHeight = currentMapData.map.length;

        // ========= 4. React App Component =========
        function App() {
            // --- Game State ---
            const [gameState, setGameState] = useState('home'); 
            const [score, setScore] = useState(0);
            const [lives, setLives] = useState(MAX_LIVES);
            const [pelletsRemaining, setPelletsRemaining] = useState(0);
            const [mapState, setMapState] = useState(JSON.parse(JSON.stringify(currentMapData.map))); 
            
            // --- Player State ---
            const playerRef = useRef({ 
                x: currentMapData.playerStart.x * gridSize + gridSize / 2, 
                y: currentMapData.playerStart.y * gridSize + gridSize / 2, 
                radius: gridSize / 2 - 2, 
                color: '#FACC15', 
                speed: 1.8,
                dx: 0, dy: 0, nextDx: 0, nextDy: 0 
            });

             // --- Ghost State ---
             const ghostsRef = useRef(currentMapData.ghostStart.map(g => ({
                x: g.x * gridSize + gridSize / 2, y: g.y * gridSize + gridSize / 2,
                startX: g.x * gridSize + gridSize / 2, startY: g.y * gridSize + gridSize / 2,
                radius: gridSize / 2 - 2, color: g.color, originalColor: g.color, speed: 1.3,
                dx: 0, dy: 0, isFrightened: false, frightenedTimer: 0, chaseMode: g.mode,
                isInBox: true, leaveBoxTimer: Math.random() * 120 + 60 
             })));
             const [ghostStates, setGhostStates] = useState(ghostsRef.current.map(g => ({ 
                id: g.originalColor, isFrightened: g.isFrightened, 
                x: g.x, y: g.y, color: g.color
             })));

            // --- Farcaster/Wallet State ---
            const [statusMessage, setStatusMessage] = useState('');
            const [isProcessing, setIsProcessing] = useState(false);
            const [fid, setFid] = useState(null);
            const [userAddress, setUserAddress] = useState(null);

            // --- Canvas Ref ---
            const canvasRef = useRef(null);
            const animationFrameId = useRef(null); 

            // --- Helper: Check Collision ---
             const checkCollision = useCallback((entity, dx, dy) => {
                const checkX = entity.x + dx;
                const checkY = entity.y + dy;
                const radius = entity.radius;
                const corners = [
                    { x: checkX - radius, y: checkY - radius }, { x: checkX + radius -1, y: checkY - radius },
                    { x: checkX - radius, y: checkY + radius -1 }, { x: checkX + radius -1, y: checkY + radius -1 }
                ];
                for (const corner of corners) {
                    const gridX = Math.floor(corner.x / gridSize);
                    const gridY = Math.floor(corner.y / gridSize);
                    if (gridX < 0 || gridX >= mapWidth || gridY < 0 || gridY >= mapHeight) {
                        if (gridY === 9 && (gridX < 0 || gridX >= mapWidth)) continue; 
                        return true; 
                    }
                    if (mapState[gridY]?.[gridX] === 1) return true; 
                }
                return false;
             }, [mapState]); 

            // --- Game Logic Functions ---
            const updatePlayer = useCallback(() => {
                const player = playerRef.current;
                if (!checkCollision(player, player.nextDx, player.nextDy)) {
                    player.dx = player.nextDx; player.dy = player.nextDy;
                }
                if (!checkCollision(player, player.dx, player.dy)) {
                    player.x += player.dx; player.y += player.dy;
                } else {
                    player.dx = 0; player.dy = 0;
                }
                if (player.x < -player.radius) player.x = canvasRef.current.width + player.radius;
                if (player.x > canvasRef.current.width + player.radius) player.x = -player.radius;
                const gridX = Math.floor(player.x / gridSize);
                const gridY = Math.floor(player.y / gridSize);
                if (gridX >= 0 && gridX < mapWidth && gridY >= 0 && gridY < mapHeight) {
                    const cell = mapState[gridY][gridX];
                    if (cell === 0 || cell === 2) { 
                        const newMap = [...mapState]; 
                        newMap[gridY] = [...newMap[gridY]]; 
                        newMap[gridY][gridX] = 3; 
                        setMapState(newMap); 
                        if(cell === 0) {
                             setScore(s => s + 10); setPelletsRemaining(p => p - 1);
                        } else { 
                             setScore(s => s + 50);
                             ghostsRef.current.forEach(g => { g.isFrightened = true; g.frightenedTimer = 300; });
                             setGhostStates(prev => prev.map(gs => ({...gs, isFrightened: true, color: '#3B82F6'})));
                        }
                    }
                }
            }, [checkCollision, mapState]);

             const updateGhosts = useCallback(() => {
                const player = playerRef.current;
                const ghosts = ghostsRef.current;
                let ghostStatesChanged = false; 
                ghosts.forEach(ghost => {
                    let stateNeedsUpdate = false; 
                    if (ghost.isFrightened) {
                        ghost.frightenedTimer--;
                         if (ghost.color !== '#3B82F6') { ghost.color = '#3B82F6'; stateNeedsUpdate = true; }
                        if (ghost.frightenedTimer <= 0) { ghost.isFrightened = false; ghost.color = ghost.originalColor; stateNeedsUpdate = true; }
                    } else if (ghost.color !== ghost.originalColor) { ghost.color = ghost.originalColor; stateNeedsUpdate = true; }
                     if (ghost.isInBox) {
                        ghost.leaveBoxTimer--;
                        if (ghost.leaveBoxTimer <= 0) {
                            ghost.isInBox = false;
                            ghost.x = currentMapData.ghostBoxExit.x * gridSize + gridSize / 2;
                            ghost.y = currentMapData.ghostBoxExit.y * gridSize + gridSize / 2;
                            ghost.dx = 0; ghost.dy = -ghost.speed; 
                        } else {
                            if (ghost.x !== ghost.startX || ghost.y !== ghost.startY) { ghost.x = ghost.startX; ghost.y = ghost.startY; stateNeedsUpdate = true; }
                            return; 
                        }
                    }
                    const directions = [ { dx: ghost.speed, dy: 0 }, { dx: -ghost.speed, dy: 0 }, { dx: 0, dy: ghost.speed }, { dx: 0, dy: -ghost.speed } ];
                    let bestDir = null;
                    if (!ghost.isFrightened) { // CHASE
                        let targetX = player.x; let targetY = player.y;
                         if (ghost.chaseMode === 'ambush') { 
                            let playerGridDx = 0; let playerGridDy = 0;
                            if (player.dx > 0) playerGridDx = 1; if (player.dx < 0) playerGridDx = -1;
                            if (player.dy > 0) playerGridDy = 1; if (player.dy < 0) playerGridDy = -1;
                            if(playerGridDx !== 0 || playerGridDy !== 0) { targetX = player.x + (playerGridDx * gridSize * 4); targetY = player.y + (playerGridDy * gridSize * 4); }
                        } else if (ghost.chaseMode === 'random') { 
                            const distanceToPlayer = Math.hypot(player.x - ghost.x, player.y - ghost.y);
                            if (distanceToPlayer < gridSize * 8) { targetX = gridSize; targetY = canvasRef.current.height - gridSize; }
                        }
                        let minDistance = Infinity;
                        for (const dir of directions) {
                            if ((dir.dx === -ghost.dx && dir.dy === -ghost.dy) && (ghost.dx !== 0 || ghost.dy !== 0)) continue; 
                            if (!checkCollision(ghost, dir.dx, dir.dy)) {
                                const newX = ghost.x + dir.dx; const newY = ghost.y + dir.dy;
                                const distance = Math.hypot(targetX - newX, targetY - newY);
                                if (distance < minDistance) { minDistance = distance; bestDir = dir; }
                            }
                        }
                    } else { // FLEE
                        let maxDistance = -1;
                        for (const dir of directions) {
                           if ((dir.dx === -ghost.dx && dir.dy === -ghost.dy) && (ghost.dx !== 0 || ghost.dy !== 0)) continue; 
                           if (!checkCollision(ghost, dir.dx, dir.dy)) {
                                const newX = ghost.x + dir.dx; const newY = ghost.y + dir.dy;
                                const distance = Math.hypot(player.x - newX, player.y - newY);
                                if (distance > maxDistance) { maxDistance = distance; bestDir = dir; }
                            }
                        }
                    }
                     let moved = false;
                     if (bestDir) { ghost.dx = bestDir.dx; ghost.dy = bestDir.dy; } 
                     else { if (!checkCollision(ghost, -ghost.dx, -ghost.dy)) { ghost.dx = -ghost.dx; ghost.dy = -ghost.dy; } 
                            else { ghost.dx = 0; ghost.dy = 0; } }
                     if (!checkCollision(ghost, ghost.dx, ghost.dy)) { ghost.x += ghost.dx; ghost.y += ghost.dy; moved = true; } 
                     else { ghost.dx = 0; ghost.dy = 0; }
                    if (ghost.x < -ghost.radius) ghost.x = canvasRef.current.width + ghost.radius;
                    if (ghost.x > canvasRef.current.width + ghost.radius) ghost.x = -ghost.radius;
                    if (moved || stateNeedsUpdate) { ghostStatesChanged = true; }
                }); 
                 if (ghostStatesChanged) {
                    setGhostStates(ghostsRef.current.map(g => ({ id: g.originalColor, isFrightened: g.isFrightened, x: g.x, y: g.y, color: g.color })));
                 }
            }, [checkCollision]);

            const checkGhostPlayerCollision = useCallback(() => {
                const player = playerRef.current;
                const ghosts = ghostsRef.current;
                let livesLost = 0;
                let ghostsEaten = []; 
                for (let i = 0; i < ghosts.length; i++) {
                    const ghost = ghosts[i];
                     if (ghost.isInBox) continue; 
                    const distance = Math.hypot(player.x - ghost.x, player.y - ghost.y);
                    if (distance < player.radius + ghost.radius) {
                        if (ghost.isFrightened) { setScore(s => s + 200); ghostsEaten.push(i); } 
                        else { livesLost++; break; }
                    }
                }
                if(ghostsEaten.length > 0) {
                     ghostsEaten.forEach(index => {
                        const ghost = ghostsRef.current[index];
                        ghost.x = ghost.startX; ghost.y = ghost.startY;
                        ghost.isFrightened = false; ghost.color = ghost.originalColor;
                        ghost.isInBox = true; ghost.leaveBoxTimer = 180; 
                     });
                     setGhostStates(prev => prev.map((gs, index) => ghostsEaten.includes(index) ? {...gs, x: ghostsRef.current[index].x, y: ghostsRef.current[index].y, isFrightened: false, color: ghostsRef.current[index].originalColor} : gs));
                }
                if (livesLost > 0) {
                    setLives(l => l - livesLost);
                    setGameState('paused'); 
                     setTimeout(() => {
                         if (lives - livesLost <= 0) { setGameState('gameover'); } 
                         else { resetPositionsAfterDeath(); setGameState('playing'); }
                     }, 1500);
                }
            }, [lives]);

            const resetPositionsAfterDeath = useCallback(() => {
                playerRef.current.x = currentMapData.playerStart.x * gridSize + gridSize / 2;
                playerRef.current.y = currentMapData.playerStart.y * gridSize + gridSize / 2;
                playerRef.current.dx = 0; playerRef.current.dy = 0; playerRef.current.nextDx = 0; playerRef.current.nextDy = 0;
                ghostsRef.current.forEach(ghost => {
                    ghost.x = ghost.startX; ghost.y = ghost.startY;
                    ghost.dx = 0; ghost.dy = 0;
                    ghost.isFrightened = false; ghost.color = ghost.originalColor;
                    ghost.isInBox = true; ghost.leaveBoxTimer = Math.random() * 120 + 60; 
                });
                setGhostStates(ghostsRef.current.map(g => ({ id: g.originalColor, isFrightened: false, x: g.x, y: g.y, color: g.color })));
            }, []);

            const checkWinCondition = useCallback(() => {
                if (pelletsRemaining <= 0 && gameState === 'playing') {
                    setGameState('gamewon');
                }
            }, [pelletsRemaining, gameState]);

             // --- Drawing Functions ---
             const drawMap = useCallback((ctx) => {
                 let pelletCount = 0;
                 for (let y = 0; y < mapHeight; y++) {
                    for (let x = 0; x < mapWidth; x++) {
                        const cell = mapState[y][x];
                        if (cell === 1) { ctx.fillStyle = '#1D4ED8'; ctx.fillRect(x * gridSize, y * gridSize, gridSize + 0.5, gridSize + 0.5); } 
                        else if (cell === 0 || cell === 2) { 
                             ctx.beginPath(); const radius = (cell === 0) ? 3 : 6;
                             ctx.arc(x * gridSize + gridSize / 2, y * gridSize + gridSize / 2, radius, 0, Math.PI * 2);
                             ctx.fillStyle = '#FDE68A'; ctx.fill(); ctx.closePath();
                             if (cell === 0) pelletCount++;
                        }
                    }
                 }
                 setPelletsRemaining(currentCount => currentCount !== pelletCount ? pelletCount : currentCount);
             }, [mapState]); 

             const drawPlayer = useCallback((ctx) => {
                 const player = playerRef.current;
                 ctx.beginPath();
                 ctx.arc(player.x, player.y, player.radius, 0.2 * Math.PI, 1.8 * Math.PI); // Pacman mouth
                 ctx.lineTo(player.x, player.y); // Center of the circle
                 ctx.closePath();
                 ctx.fillStyle = player.color;
                 ctx.fill();
             }, []); 

             const drawGhosts = useCallback((ctx) => {
                 ghostStates.forEach(ghost => {
                    ctx.beginPath();
                    ctx.arc(ghost.x, ghost.y, ghost.radius, Math.PI, 0); // Half circle top
                    ctx.lineTo(ghost.x + ghost.radius, ghost.y + ghost.radius * 1.5); // Bottom right
                    // Wavy bottom
                    ctx.quadraticCurveTo(ghost.x + ghost.radius * 0.5, ghost.y + ghost.radius * 1.2, ghost.x, ghost.y + ghost.radius * 1.5); 
                    ctx.quadraticCurveTo(ghost.x - ghost.radius * 0.5, ghost.y + ghost.radius * 1.2, ghost.x - ghost.radius, ghost.y + ghost.radius * 1.5);
                    ctx.lineTo(ghost.x - ghost.radius, ghost.y); // Bottom left back to arc start
                    ctx.closePath();
                    ctx.fillStyle = ghost.color;
                    ctx.fill();

                    // Eyes
                    const eyeOffsetX = ghost.radius * 0.3;
                    const eyeOffsetY = -ghost.radius * 0.2;
                    const eyeRadius = ghost.radius * 0.2;
                    const pupilRadius = eyeRadius * 0.5;

                    ctx.fillStyle = 'white'; // Sclera
                    ctx.beginPath();
                    ctx.arc(ghost.x - eyeOffsetX, ghost.y + eyeOffsetY, eyeRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(ghost.x + eyeOffsetX, ghost.y + eyeOffsetY, eyeRadius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'black'; // Pupil
                    ctx.beginPath();
                    ctx.arc(ghost.x - eyeOffsetX, ghost.y + eyeOffsetY, pupilRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(ghost.x + eyeOffsetX, ghost.y + eyeOffsetY, pupilRadius, 0, Math.PI * 2);
                    ctx.fill();

                 });
             }, [ghostStates]); 


            // --- Game Loop ---
            const gameLoop = useCallback(() => {
                if (gameState !== 'playing') {
                    cancelAnimationFrame(animationFrameId.current);
                    return;
                }
                const canvas = canvasRef.current;
                if (!canvas) return; // Add check for canvas
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear
                updatePlayer(); updateGhosts(); checkGhostPlayerCollision(); checkWinCondition(); // Update
                drawMap(ctx); drawGhosts(ctx); drawPlayer(ctx); // Draw
                animationFrameId.current = requestAnimationFrame(gameLoop);
            }, [gameState, updatePlayer, updateGhosts, checkGhostPlayerCollision, checkWinCondition, drawMap, drawPlayer, drawGhosts]); 


            // --- Effects ---
            useEffect(() => {
                if (gameState === 'playing') {
                    console.log("Starting game loop");
                    animationFrameId.current = requestAnimationFrame(gameLoop);
                } else {
                    console.log("Stopping game loop");
                    cancelAnimationFrame(animationFrameId.current);
                }
                return () => cancelAnimationFrame(animationFrameId.current); 
            }, [gameState, gameLoop]); 

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (gameState !== 'playing') return; 
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) e.preventDefault();
                    const player = playerRef.current;
                    switch (e.key) {
                        case 'ArrowUp':    player.nextDx = 0; player.nextDy = -player.speed; break;
                        case 'ArrowDown':  player.nextDx = 0; player.nextDy = player.speed; break;
                        case 'ArrowLeft':  player.nextDx = -player.speed; player.nextDy = 0; break;
                        case 'ArrowRight': player.nextDx = player.speed; player.nextDy = 0; break;
                    }
                };
                const canvas = canvasRef.current;
                if(canvas && gameState === 'playing') { // Only focus/listen when playing
                     canvas.setAttribute('tabindex', '0'); 
                     canvas.focus();
                     window.addEventListener('keydown', handleKeyDown);
                     console.log("Keydown listener attached");
                }
                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    console.log("Keydown listener removed");
                }
            }, [gameState]); // Depend only on gameState

            useEffect(() => {
                if (lives <= 0 && gameState === 'playing') { 
                    console.log("Game Over condition met (lives <= 0)");
                    setGameState('gameover');
                }
            }, [lives, gameState]);

             useEffect(() => {
                 let count = 0;
                 mapState.forEach(row => row.forEach(cell => { if (cell === 0) count++; }));
                 setPelletsRemaining(count);
                 console.log("Initial pellet count:", count);
             }, []); 


            // --- Wallet/Payment Functions ---
             const handleConnectWallet = async () => {
                setIsProcessing(true);
                setStatusMessage('1/3: Locating provider...'); console.log("Connecting...");
                try {
                  const provider = await getProvider();
                  if (!provider) throw new Error('No provider. Use Farcaster client or wallet extension.');
                  setStatusMessage('2/3: Requesting accounts...'); console.log("Requesting accounts...");
                  const accounts = await provider.request({ method: 'eth_requestAccounts' });
                  if (accounts && accounts.length > 0) {
                      const addr = accounts[0]; setUserAddress(addr); console.log("Account:", addr);
                      setStatusMessage('3/3: Getting user data...'); console.log("Getting user data...");
                      try {
                          if (sdk && typeof sdk.getUserData === 'function') {
                              const user = await sdk.getUserData();
                              if (user && user.fid) { setFid(user.fid); setStatusMessage(`‚úÖ Connected! FID: ${user.fid}`); console.log("User:", user); } 
                              else { setFid(null); setStatusMessage(`‚úÖ Connected: ${addr.slice(0,6)}...`); console.log("FID not available."); }
                          } else { setFid(null); setStatusMessage(`‚úÖ Connected: ${addr.slice(0,6)}...`); console.log("sdk.getUserData unavailable."); }
                      } catch (fidError) { setFid(null); setStatusMessage(`‚úÖ Connected: ${addr.slice(0,6)}...`); console.warn("FID error:", fidError); }
                  } else throw new Error('No accounts returned.');
                } catch (e) { console.error('Connect error:', e); setUserAddress(null); setFid(null); setStatusMessage(`‚ùå Error: ${e.message}`); }
                setIsProcessing(false);
             };

             const handleStartOrRestart = async () => {
                if (!userAddress) { setStatusMessage('Please connect wallet first.'); return; }
                if (DEVELOPER_WALLET === '0xYourWalletAddressHere' || !DEVELOPER_WALLET.startsWith('0x')) { setStatusMessage('‚ö†Ô∏è Dev: Set valid wallet address!'); return; }
                setIsProcessing(true); setStatusMessage('1/3: Locating provider...'); console.log("Starting/Restarting...");
                try {
                  const provider = await getProvider();
                  if (!provider) throw new Error('No provider found.');
                  setStatusMessage('2/3: Sending payment...'); console.log("Sending payment...");
                  const hash = await provider.request({ method: 'eth_sendTransaction', params: [{ from: userAddress, to: DEVELOPER_WALLET, value: parseEther(GAME_FEE_ETH) }] });
                  setStatusMessage('‚úÖ Payment complete! Starting...'); console.log("TX Hash:", hash);
                  setScore(0); setLives(MAX_LIVES); setMapState(JSON.parse(JSON.stringify(currentMapData.map))); 
                  playerRef.current.x = currentMapData.playerStart.x * gridSize + gridSize / 2; playerRef.current.y = currentMapData.playerStart.y * gridSize + gridSize / 2;
                  playerRef.current.dx = 0; playerRef.current.dy = 0; playerRef.current.nextDx = 0; playerRef.current.nextDy = 0;
                  ghostsRef.current.forEach((g, i) => { const s = currentMapData.ghostStart[i]; g.x = s.x * gridSize + gridSize / 2; g.y = s.y * gridSize + gridSize / 2; g.isFrightened = false; g.color = g.originalColor; g.isInBox = true; g.leaveBoxTimer = Math.random() * 120 + 60; });
                  setGhostStates(ghostsRef.current.map(g => ({ id: g.originalColor, isFrightened: false, x: g.x, y: g.y, color: g.color })));
                  let pCount = 0; mapState.forEach(r => r.forEach(c => { if (c === 0) pCount++; })); setPelletsRemaining(pCount);
                  setTimeout(() => { setGameState('playing'); setIsProcessing(false); setStatusMessage(''); if(canvasRef.current) canvasRef.current.focus(); }, 1000);
                } catch (e) { console.error('Start/Restart error:', e); setStatusMessage(`‚ùå Failed: ${e.message.split('.')[0]}.`); setIsProcessing(false); }
             };

            // --- UI Rendering ---
            if (gameState === 'home') {
                const isWalletConnected = !!userAddress;
                 // HNA ZDNA L-BACKGROUND IMAGE
                 return createElement('div', { 
                        className: "min-h-screen flex flex-col items-center justify-center p-4 text-center relative home-overlay", // Zdna relative w home-overlay
                        style: {
                            backgroundImage: `url('image_e58548.png')`, // L-IMAGE LI SIFTI
                            backgroundSize: 'cover',
                            backgroundPosition: 'center',
                            backgroundRepeat: 'no-repeat'
                        }
                    }, 
                    // Content wrapped f div jdid bach ywli fog l'overlay
                    createElement('div', {className: "home-content w-full max-w-xs"}, 
                        createElement('h1', { className: "text-5xl font-bold arcade-header tracking-tight mb-4" }, "Pixel Muncher"),
                        createElement('h2', { className: "text-xl text-cyan-300 mb-8" }, ""), // 7ydna ljumla
                        createElement('div', { className: "flex flex-col gap-4 w-full" },
                            createElement('button', {
                               onClick: handleConnectWallet, disabled: isProcessing || isWalletConnected,
                               className: "secondary-button w-full disabled:opacity-50 disabled:cursor-not-allowed"
                            }, isWalletConnected ? `‚úÖ Connected: ${userAddress.slice(0,6)}...` : 'Connect Wallet'),
                            createElement('button', {
                               onClick: handleStartOrRestart, disabled: !isWalletConnected || isProcessing,
                               className: "primary-button w-full disabled:opacity-50 disabled:cursor-not-allowed"
                            }, isProcessing ? statusMessage : `Pay ${GAME_FEE_ETH} ETH & Play`),
                        ),
                        statusMessage && !isProcessing && createElement('div', {
                            className: `mt-6 p-3 rounded-lg font-semibold text-sm w-full ${ // 7ydna max-w-xs mn hna
                            statusMessage.includes('Error') || statusMessage.includes('failed') || statusMessage.includes('‚ö†Ô∏è') || statusMessage.includes('‚ùå') ? 'bg-red-500/80' : 
                            statusMessage.includes('‚úÖ') ? 'bg-green-500/80' : 'bg-blue-500/80'}`
                        }, statusMessage)
                    ) // Sddina home-content div
                 );
            }

            if (gameState === 'gameover' || gameState === 'gamewon') {
                 return createElement('div', { id:"gameModal", className: "modal", style: { display: 'flex' } }, 
                     createElement('div', { className: "modal-content" },
                         createElement('h2', { id: "modalTitle", className: "text-3xl font-bold mb-4" }, gameState === 'gamewon' ? 'üéâ You Won! üéâ' : 'Game Over!'),
                         createElement('p', { id:"modalScore", className: "text-lg mb-6" }, `Final Score: ${score}`),
                         createElement('button', { 
                             id:"restartButton", onClick: handleStartOrRestart, disabled: isProcessing,
                             className: "primary-button w-full" 
                         }, isProcessing ? statusMessage : `Pay ${GAME_FEE_ETH} ETH & Play Again`)
                     )
                 );
            }

            // Playing State UI
            return createElement('div', { className: "flex flex-col items-center w-full max-w-[420px]" }, 
                createElement('header', { className: "text-center mb-2" },
                   createElement('h1', { className: "text-3xl font-bold arcade-header tracking-tight" }, "Pixel Muncher")
                ),
                createElement('div', { className: "flex justify-between w-full text-lg mb-2 px-1" },
                    createElement('div', { className: "font-semibold" }, 'Score: ', createElement('span', { id: "score", className: "text-yellow-400" }, score)),
                    createElement('div', { className: "font-semibold" }, 'Lives: ', createElement('span', { id: "lives", className: "text-red-500" }, lives))
                ),
                createElement('canvas', { ref: canvasRef, id: "gameCanvas", width: mapWidth * gridSize, height: mapHeight * gridSize }),
                createElement('div', { className: "mt-3 text-center text-sm text-gray-400" },
                  createElement('p', null, 'Use ', createElement('span', {className: "text-yellow-400 font-bold"}, 'Arrow Keys'), ' to move.')
                )
             );
        }

        // ========= 5. Render App =========
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(createElement(App));

    </script>
</body>
</html>

