<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Muncher - Farcaster</title>

    <!-- 1. Tailwind (Design) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Farcaster Embed Metadata & Open Graph -->
    <meta name="fc:miniapp" content='{
      "version":"next",
      "imageUrl":"https://<YOUR_APP_URL>/pixel-muncher-embed.png", 
      "button":{
          "title":"Play Pixel Muncher!",
          "action":{
          "type":"launch_miniapp",
          "name":"Pixel Muncher",
          "url":"https://<YOUR_APP_URL>" 
          }
      },
      "castShareUrl": "https://<YOUR_APP_URL>", 
      "ogTitle": "Pixel Muncher - Mini App", 
      "ogDescription": "Classic arcade munching fun!", 
      "ogImageUrl": "https://<YOUR_APP_URL>/pixel-muncher-embed.png" 
    }' />

    <!-- 3. React -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
            overflow: hidden; /* Hide scrollbars */
            color: #e7ecf0;
        }
        canvas {
            background-color: #000;
            border: 4px solid #374151; /* gray-700 */
            border-radius: 8px;
            display: block; /* Remove extra space below canvas */
            touch-action: none; /* Disable default touch actions */
        }
        .arcade-header {
            background: linear-gradient(90deg, rgba(250, 204, 21, 1) 0%, rgba(236, 72, 153, 1) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .game-button {
            transition: all 0.3s ease;
        }
        .game-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);
        }
        .modal {
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex; /* Use flex for centering */
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #1F2937; /* bg-gray-800 */
            padding: 24px;
            border-radius: 12px;
            border: 1px solid #4B5563; /* bg-gray-600 */
            width: 90%;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }
         /* Simple glow effect for buttons */
        .primary-button {
             padding:14px 28px; background:linear-gradient(135deg,#ff8c42,#ff6b1a); color:#fff; border:none; border-radius:12px; font-weight:900; font-size:16px; cursor:pointer; box-shadow:0 6px 20px rgba(255,107,26,0.4); transition:all .2s; text-transform:uppercase; letter-spacing:.5px; 
        }
         .primary-button:hover:not(:disabled){ transform:translateY(-2px); box-shadow:0 8px 25px rgba(255,107,26,.5); }
         .primary-button:disabled{ opacity:.6; cursor:not-allowed; }

         .secondary-button{ padding:12px 24px; background:linear-gradient(135deg,#38bdf8,#34d399); color:#0a1929; border:none; border-radius:10px; font-weight:900; font-size:14px; cursor:pointer; box-shadow:0 4px 15px rgba(56,189,248,.3); transition:all .2s; letter-spacing:.5px; text-transform:uppercase; }
          .secondary-button:hover:not(:disabled){ transform:translateY(-2px); }
         .secondary-button:disabled{ opacity:.6; cursor:not-allowed; }
         
         /* Background overlay for better text readability on home */
        .home-overlay::before {
            content: "";
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(17, 24, 39, 0.7); /* bg-gray-900 with opacity */
            z-index: 1; /* Place overlay below content */
        }
        .home-content {
             position: relative; /* Ensure content is above overlay */
             z-index: 2;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center p-2 sm:p-4">
    <div id="root"></div>

    <script type="module">
        // ========= 1. Import SDK & Call Ready =========
        import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
        sdk.actions.ready();
        console.log("Farcaster SDK ready() called immediately.");

        // ========= 2. React Setup & Helpers =========
        const { useState, useEffect, createElement, useRef, useCallback } = React;

        function parseEther(x) {
            const [w, f = ""] = String(x).split('.');
            const frac = (f + '0'.repeat(18)).slice(0, 18);
            return '0x' + (BigInt(w) * 10n ** 18n + BigInt(frac)).toString(16);
        }

        async function getProvider() {
            try {
                const p = await sdk.wallet.getEthereumProvider();
                if (p) return p;
            } catch (e) { console.warn("Farcaster provider error", e); }
            return window.ethereum ?? null;
        }

        // ========= 3. Game Constants & Config =========
        const gridSize = 20;
        const GAME_FEE_ETH = '0.00001'; 
        const DEVELOPER_WALLET = '0x0e315015a4ee8d5d6c4b43e300df76b965d55bdd'; 
        const MAX_LIVES = 3;

        // --- Maps Data (BDDLNA CHI 7ITAN L 0/3) ---
        // Maze layout: 1 = Wall, 0 = Pellet, 2 = Power Pellet, 3 = Empty
        const map1 = [ // Map 1: Ft7na chwiya dyal triqan 7da l box
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,2,1],
            [1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,0,1],
            [1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1],
            [1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1],
            [1,0,1,1,0,1,3,3,3,3,3,3,3,3,3,1,0,1,1,0,1],
            [1,0,1,1,0,0,3,1,1,1,1,1,1,1,3,0,0,1,1,0,1], // Changed 1s to 0s/3s near exit
            [1,0,0,0,0,1,3,1,3,3,3,3,3,1,3,1,0,0,0,0,1], 
            [1,1,1,1,0,1,3,1,3,3,3,3,3,1,3,1,0,1,1,1,1], 
            [3,3,3,1,0,1,3,0,0,0,0,0,0,0,3,1,0,1,3,3,3], // Tunnel row, opened path below box
            [1,1,1,1,0,1,3,3,3,3,3,3,3,3,3,1,0,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,0,1],
            [1,0,1,1,0,0,0,0,0,0,3,0,0,0,0,0,0,1,1,0,1], 
            [1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1],
            [1,0,1,1,1,1,0,0,0,0,1,0,0,0,0,1,1,1,1,0,1],
            [1,2,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
         const map2 = [ // Map 2: Ft7na triqan f l wst w lfoq
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,0,2,1],
            [1,0,1,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,1,0,1],
            [1,0,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,0,1],
            [1,0,0,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,0,1], // Opened center top
            [1,1,1,0,0,0,0,3,3,3,3,3,3,3,0,0,0,0,1,1,1],
            [1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,1,1,0,0,0,1], // Opened near box
            [1,0,1,0,1,1,0,1,3,3,3,3,3,1,0,1,1,0,1,0,1], 
            [1,0,1,0,0,0,0,1,3,3,3,3,3,1,0,0,0,0,1,0,1], 
            [3,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,0,3], // Tunnel row, opened path below box
            [1,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1], // Opened bottom center
            [1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,0,1],
            [1,0,0,0,0,1,1,0,0,0,3,0,0,0,1,1,0,0,0,0,1], 
            [1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1],
            [1,0,0,1,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,1],
            [1,0,1,1,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1],
            [1,2,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,0,0,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
         const map3 = [ // Map 3: Ft7na bzaf dyal triqan f l wst
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1], // Opened vertical path
            [1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1], // Opened horizontal path
            [1,0,1,0,1,1,0,1,3,3,3,3,3,1,0,1,1,0,1,0,1], 
            [1,0,1,0,1,1,0,1,3,3,3,3,3,1,0,1,1,0,1,0,1], 
            [1,2,0,0,1,1,0,1,3,3,3,3,3,1,0,1,1,0,0,2,1], // Opened path near Power Pellet
            [1,1,1,0,1,1,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1], 
            [3,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,3], // Tunnel row, more open
            [1,1,1,0,1,1,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1], 
            [1,2,0,0,1,1,0,1,3,3,3,3,3,1,0,1,1,0,0,2,1], // Opened path near Power Pellet
            [1,0,1,0,1,1,0,1,3,3,3,3,3,1,0,1,1,0,1,0,1], 
            [1,0,1,0,1,1,0,1,3,3,3,3,3,1,0,1,1,0,1,0,1], 
            [1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1], // Opened horizontal path
            [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1], // Opened vertical path
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        
        const allMaps = [ 
            { map: map1, playerStart: { x: 10, y: 13 }, ghostStart: [ { x: 10, y: 7, color: '#EF4444', mode: 'direct'}, { x: 9, y: 8, color: '#F472B6', mode: 'ambush'}, { x: 10, y: 8, color: '#22D3EE', mode: 'direct'}, { x: 11, y: 8, color: '#F97316', mode: 'random'} ], ghostBoxExit: { x: 10, y: 6 } }, 
            { map: map2, playerStart: { x: 10, y: 12 }, ghostStart: [ { x: 10, y: 7, color: '#EF4444', mode: 'direct'}, { x: 9, y: 8, color: '#F472B6', mode: 'ambush'}, { x: 10, y: 8, color: '#22D3EE', mode: 'direct'}, { x: 11, y: 8, color: '#F97316', mode: 'random'} ], ghostBoxExit: { x: 10, y: 6 } }, 
            { map: map3, playerStart: { x: 10, y: 14 }, ghostStart: [ { x: 10, y: 6, color: '#EF4444', mode: 'direct'}, { x: 9, y: 7, color: '#F472B6', mode: 'ambush'}, { x: 10, y: 7, color: '#22D3EE', mode: 'direct'}, { x: 11, y: 7, color: '#F97316', mode: 'random'} ], ghostBoxExit: { x: 10, y: 5 } } 
        ];
        let currentMapData = allMaps[0]; 
        let mapWidth = 0; 
        let mapHeight = 0; 

        // ========= 4. React App Component =========
        function App() {
            // --- Game State ---
            const [gameState, setGameState] = useState('home'); 
            const [currentRound, setCurrentRound] = useState(1); 
            const [score, setScore] = useState(0);
            const [lives, setLives] = useState(MAX_LIVES);
            const [pelletsRemaining, setPelletsRemaining] = useState(0);
            const [mapState, setMapState] = useState(null); 
            
            // --- Player State ---
            const playerRef = useRef({ x: 0, y: 0, radius: gridSize / 2 - 2, color: '#FACC15', speed: 1.8, dx: 0, dy: 0, nextDx: 0, nextDy: 0 });
             // --- Ghost State ---
             const ghostsRef = useRef([]); 
             const [ghostStates, setGhostStates] = useState([]); 

            // --- Farcaster/Wallet State ---
            const [statusMessage, setStatusMessage] = useState('');
            const [isProcessing, setIsProcessing] = useState(false);
            const [fid, setFid] = useState(null);
            const [userAddress, setUserAddress] = useState(null);

            // --- Canvas Ref ---
            const canvasRef = useRef(null);
            const animationFrameId = useRef(null); 

            // --- Helper: Check Collision (RJ3NA L-CHECK DYAL L7ITAN) ---
             const checkCollision = useCallback((entity, dx, dy) => {
                 if (!mapState) return true; // Blocki ila l'map ma wajdach
                 const checkX = entity.x + dx;
                 const checkY = entity.y + dy;
                 const radius = entity.radius;
                 const corners = [ { x: checkX - radius, y: checkY - radius }, { x: checkX + radius -1, y: checkY - radius }, { x: checkX - radius, y: checkY + radius -1 }, { x: checkX + radius -1, y: checkY + radius -1 } ];
                 for (const corner of corners) {
                    const gridX = Math.floor(corner.x / gridSize);
                    const gridY = Math.floor(corner.y / gridSize);
                    // BDIL: Updated tunnel logic based on currentRound
                    let tunnelRowY = -1;
                    if (currentRound === 1 || currentRound === 2) tunnelRowY = 9;
                    else if (currentRound === 3) tunnelRowY = 9; // Map 3 tunnel row updated
                    
                    if (gridX < 0 || gridX >= mapWidth || gridY < 0 || gridY >= mapHeight) {
                        if (gridY === tunnelRowY && (gridX < 0 || gridX >= mapWidth)) continue; // Allow tunnel wrapping
                        return true; // Hit boundary
                    }
                    // RJ3NA L-CHECK DYAL L7ITAN (MAPSTATE === 1)
                    if (mapState[gridY]?.[gridX] === 1) return true; 
                }
                return false; // Makaynch collision
             }, [mapState, currentRound]); 

            // --- Game Logic Functions ---
            const loadRoundData = useCallback((roundNum) => { /* ... kima kan ... */ 
                 if (roundNum > allMaps.length || roundNum < 1) { console.error("Invalid round:", roundNum); setGameState('home'); return; }
                 console.log(`Loading round ${roundNum}`); setCurrentRound(roundNum);
                 currentMapData = allMaps[roundNum - 1]; mapWidth = currentMapData.map[0].length; mapHeight = currentMapData.map.length;
                 setMapState(JSON.parse(JSON.stringify(currentMapData.map)));
                 playerRef.current.x = currentMapData.playerStart.x * gridSize + gridSize / 2; playerRef.current.y = currentMapData.playerStart.y * gridSize + gridSize / 2;
                 playerRef.current.dx = 0; playerRef.current.dy = 0; playerRef.current.nextDx = 0; playerRef.current.nextDy = 0;
                 ghostsRef.current = currentMapData.ghostStart.map(g => ({ x: g.x * gridSize + gridSize / 2, y: g.y * gridSize + gridSize / 2, startX: g.x * gridSize + gridSize / 2, startY: g.y * gridSize + gridSize / 2, radius: gridSize / 2 - 2, color: g.color, originalColor: g.color, speed: 1.3, dx: 0, dy: 0, isFrightened: false, frightenedTimer: 0, chaseMode: g.mode, isInBox: true, leaveBoxTimer: Math.random() * 120 + 60 }));
                 setGhostStates(ghostsRef.current.map(g => ({ id: g.originalColor, isFrightened: g.isFrightened, x: g.x, y: g.y, color: g.color })));
                 let pCount = 0; currentMapData.map.forEach(r => r.forEach(c => { if (c === 0) pCount++; })); setPelletsRemaining(pCount); console.log("Pellets:", pCount);
                 if(canvasRef.current) { canvasRef.current.width = mapWidth * gridSize; canvasRef.current.height = mapHeight * gridSize; }
            }, []); 

            // RJ3NA L-CHECK DYAL COLLISION QBL MA NBDLO DIRECTION W QBL MA NT7RKO
            const updatePlayer = useCallback(() => { /* ... kima kan f version l msll7a ... */ 
                if (!canvasRef.current) return; const p = playerRef.current; if (!checkCollision(p, p.nextDx, p.nextDy)) { p.dx = p.nextDx; p.dy = p.nextDy; }
                if (!checkCollision(p, p.dx, p.dy)) { p.x += p.dx; p.y += p.dy; } else { p.dx = 0; p.dy = 0; }
                const cw = canvasRef.current.width; if (p.x < -p.radius) p.x = cw + p.radius; if (p.x > cw + p.radius) p.x = -p.radius;
                const gx = Math.floor(p.x / gridSize); const gy = Math.floor(p.y / gridSize);
                if (gx >= 0 && gx < mapWidth && gy >= 0 && gy < mapHeight) { const cell = mapState?.[gy]?.[gx]; if (cell === 0 || cell === 2) { setMapState(prevMap => { const nm = [...prevMap]; nm[gy] = [...nm[gy]]; nm[gy][gx] = 3; return nm; }); if(cell === 0) { setScore(s => s + 10); setPelletsRemaining(p => p - 1); } else { setScore(s => s + 50); ghostsRef.current.forEach(g => { g.isFrightened = true; g.frightenedTimer = 300; }); setGhostStates(prev => prev.map(gs => ({...gs, isFrightened: true, color: '#3B82F6'}))); } } }
            }, [checkCollision, mapState]); 

             // RJ3NA L-CHECK DYAL COLLISION F AI W F L-MOVEMENT + SL7NA LOGIC DYAL L-KHROJ
             const updateGhosts = useCallback(() => { /* ... kima kan f version l msll7a ... */ 
                if (!canvasRef.current) return; const player = playerRef.current; const ghosts = ghostsRef.current; let changed = false; 
                ghosts.forEach(g => { let needsUpdate = false; 
                    if (g.isFrightened) { g.frightenedTimer--; if (g.color !== '#3B82F6') { g.color = '#3B82F6'; needsUpdate = true; } if (g.frightenedTimer <= 0) { g.isFrightened = false; g.color = g.originalColor; needsUpdate = true; } } 
                    else if (g.color !== g.originalColor) { g.color = g.originalColor; needsUpdate = true; }
                    if (g.isInBox) { g.leaveBoxTimer--; if (g.leaveBoxTimer <= 0) { const exit = allMaps[currentRound - 1].ghostBoxExit; const tx = exit.x * gridSize + gridSize / 2; const ty = exit.y * gridSize + gridSize / 2; let mx = 0; let my = 0; if (Math.abs(g.x - tx) > g.speed / 2) mx = Math.sign(tx - g.x) * g.speed; else g.x = tx; if (Math.abs(g.y - ty) > g.speed / 2) my = Math.sign(ty - g.y) * g.speed; else g.y = ty; if (my !== 0) { g.dx = 0; g.dy = my; } else if (mx !== 0) { g.dx = mx; g.dy = 0; } else { g.dx = 0; g.dy = -g.speed; g.isInBox = false; console.log(`Ghost ${g.originalColor} leaving`); } g.x += g.dx; g.y += g.dy; needsUpdate = true; return; } else { if (g.x !== g.startX || g.y !== g.startY) { g.x = g.startX; g.y = g.startY; needsUpdate = true; } return; } }
                    const dirs = [ { dx: g.speed, dy: 0 }, { dx: -g.speed, dy: 0 }, { dx: 0, dy: g.speed }, { dx: 0, dy: -g.speed } ]; let bestDir = null;
                    if (!g.isFrightened) { let tx = player.x, ty = player.y; if (g.chaseMode === 'ambush') { let pdx=0,pdy=0; if(player.dx > 0)pdx=1;if(player.dx<0)pdx=-1;if(player.dy>0)pdy=1;if(player.dy<0)pdy=-1; if(pdx!==0||pdy!==0){tx=player.x+(pdx*gridSize*4);ty=player.y+(pdy*gridSize*4);}} else if (g.chaseMode === 'random') { const d = Math.hypot(player.x-g.x, player.y-g.y); if(d<gridSize*8){tx=gridSize;ty=canvasRef.current.height-gridSize;}} let minDist=Infinity; for(const dir of dirs){ if((dir.dx===-g.dx && dir.dy===-g.dy)&&(g.dx!==0||g.dy!==0)) continue; if(!checkCollision(g,dir.dx,dir.dy)){ const nx=g.x+dir.dx, ny=g.y+dir.dy; const dist=Math.hypot(tx-nx,ty-ny); if(dist<minDist){minDist=dist;bestDir=dir;}}} } 
                    else { let maxDist=-1; for(const dir of dirs){ if((dir.dx===-g.dx && dir.dy===-g.dy)&&(g.dx!==0||g.dy!==0)) continue; if(!checkCollision(g,dir.dx,dir.dy)){ const nx=g.x+dir.dx, ny=g.y+dir.dy; const dist=Math.hypot(player.x-nx,player.y-ny); if(dist>maxDist){maxDist=dist;bestDir=dir;}}} }
                    let moved = false; if (bestDir) { g.dx = bestDir.dx; g.dy = bestDir.dy; } else { if (!checkCollision(g, -g.dx, -g.dy)) { g.dx = -g.dx; g.dy = -g.dy; } else { g.dx = 0; g.dy = 0; } }
                    if (!checkCollision(g, g.dx, g.dy)) { g.x += g.dx; g.y += g.dy; moved = true; } else { g.dx = 0; g.dy = 0; }
                    const cw = canvasRef.current.width; if (g.x < -g.radius) g.x = cw + g.radius; if (g.x > cw + g.radius) g.x = -g.radius;
                    if (moved || needsUpdate) changed = true; 
                }); 
                if (changed) { setGhostStates(ghostsRef.current.map(g => ({ id: g.originalColor, isFrightened: g.isFrightened, x: g.x, y: g.y, color: g.color }))); }
            }, [checkCollision, currentRound]); 

            const checkGhostPlayerCollision = useCallback(() => { /* ... kima kan ... */ 
                const player = playerRef.current; const ghosts = ghostsRef.current; let livesLost = 0; let ghostsEaten = []; 
                for (let i = 0; i < ghosts.length; i++) { const ghost = ghosts[i]; if (ghost.isInBox) continue; const d = Math.hypot(player.x - ghost.x, player.y - ghost.y); if (d < player.radius + ghost.radius) { if (ghost.isFrightened) { setScore(s => s + 200); ghostsEaten.push(i); } else { livesLost++; break; } } }
                if(ghostsEaten.length > 0) { ghostsEaten.forEach(i => { const g = ghostsRef.current[i]; g.x = g.startX; g.y = g.startY; g.isFrightened = false; g.color = g.originalColor; g.isInBox = true; g.leaveBoxTimer = 180; }); setGhostStates(p => p.map((gs, i) => ghostsEaten.includes(i) ? {...gs, x: ghostsRef.current[i].x, y: ghostsRef.current[i].y, isFrightened: false, color: ghostsRef.current[i].originalColor} : gs)); }
                if (livesLost > 0) { setLives(l => l - livesLost); setGameState('paused'); setTimeout(() => { if (lives - livesLost <= 0) { setGameState('gameover'); } else { resetPositionsAfterDeath(); setGameState('playing'); } }, 1500); }
             }, [lives]); 

            const resetPositionsAfterDeath = useCallback(() => { /* ... kima kan ... */ 
                 const mapDataForReset = allMaps[currentRound - 1]; playerRef.current.x = mapDataForReset.playerStart.x * gridSize + gridSize / 2; playerRef.current.y = mapDataForReset.playerStart.y * gridSize + gridSize / 2; playerRef.current.dx = 0; playerRef.current.dy = 0; playerRef.current.nextDx = 0; playerRef.current.nextDy = 0;
                 ghostsRef.current.forEach((g, i) => { const s = mapDataForReset.ghostStart[i]; g.x = s.x * gridSize + gridSize / 2; g.y = s.y * gridSize + gridSize / 2; g.startX = g.x; g.startY = g.y; g.dx = 0; g.dy = 0; g.isFrightened = false; g.color = g.originalColor; g.isInBox = true; g.leaveBoxTimer = Math.random() * 120 + 60; });
                 setGhostStates(ghostsRef.current.map(g => ({ id: g.originalColor, isFrightened: false, x: g.x, y: g.y, color: g.color })));
            }, [currentRound]); 

            const checkWinCondition = useCallback(() => { /* ... kima kan ... */ 
                if (pelletsRemaining <= 0 && gameState === 'playing') { console.log(`Round ${currentRound} cleared!`); if (currentRound < allMaps.length) { setGameState('round_won'); } else { setGameState('gamewon'); } }
            }, [pelletsRemaining, gameState, currentRound]);

             // --- Drawing Functions ---
             const drawMap = useCallback((ctx) => { /* ... kima kan ... */ 
                 if (!mapState) return; let pCount = 0;
                 for (let y = 0; y < mapHeight; y++) { for (let x = 0; x < mapWidth; x++) { const c = mapState?.[y]?.[x]; if (c === 1) { ctx.fillStyle = '#1D4ED8'; ctx.fillRect(x * gridSize, y * gridSize, gridSize + 0.5, gridSize + 0.5); } else if (c === 0 || c === 2) { ctx.beginPath(); const r = (c === 0) ? 3 : 6; ctx.arc(x * gridSize + gridSize / 2, y * gridSize + gridSize / 2, r, 0, Math.PI * 2); ctx.fillStyle = '#FDE68A'; ctx.fill(); ctx.closePath(); if (c === 0) pCount++; } } }
                 setPelletsRemaining(cc => cc !== pCount ? pCount : cc);
             }, [mapState]); 

             const drawPlayer = useCallback((ctx) => { /* ... kima kan ... */ 
                 const p = playerRef.current; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.closePath(); ctx.fillStyle = p.color; ctx.fill();
             }, []); 

             const drawGhosts = useCallback((ctx) => { /* ... kima kan (circles) ... */ 
                 ghostStates.forEach(g => { ctx.beginPath(); ctx.arc(g.x, g.y, gridSize / 2 - 2, 0, Math.PI * 2); ctx.fillStyle = g.color; ctx.fill(); ctx.closePath(); });
             }, [ghostStates]); 


            // --- Game Loop ---
            const gameLoop = useCallback(() => { /* ... kima kan ... */ 
                const canvas = canvasRef.current; if (!canvas) return; const ctx = canvas.getContext('2d'); ctx.clearRect(0, 0, canvas.width, canvas.height); 
                if (gameState === 'playing') { updatePlayer(); updateGhosts(); checkGhostPlayerCollision(); checkWinCondition(); }
                drawMap(ctx); drawGhosts(ctx); drawPlayer(ctx); 
                if (gameState === 'playing' || gameState === 'paused') { animationFrameId.current = requestAnimationFrame(gameLoop); } 
                else { console.log("Loop stopping:", gameState); }
            }, [gameState, updatePlayer, updateGhosts, checkGhostPlayerCollision, checkWinCondition, drawMap, drawPlayer, drawGhosts]); 


            // --- Effects ---
            useEffect(() => { /* ... kima kan ... */ 
                if (gameState === 'playing' || gameState === 'paused') { console.log("Starting/Resuming loop:", gameState); animationFrameId.current = requestAnimationFrame(gameLoop); } 
                else { console.log("Stopping loop:", gameState); cancelAnimationFrame(animationFrameId.current); }
                return () => { console.log("Cleaning up frame"); cancelAnimationFrame(animationFrameId.current); }
            }, [gameState, gameLoop]); 

            useEffect(() => { /* ... kima kan ... */ 
                const handleKeyDown = (e) => { if (gameState !== 'playing') return; if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) e.preventDefault(); const p = playerRef.current; switch (e.key) { case 'ArrowUp': p.nextDx = 0; p.nextDy = -p.speed; break; case 'ArrowDown': p.nextDx = 0; p.nextDy = p.speed; break; case 'ArrowLeft': p.nextDx = -p.speed; p.nextDy = 0; break; case 'ArrowRight': p.nextDx = p.speed; p.nextDy = 0; break; } };
                const canvas = canvasRef.current; if(canvas) { if (gameState === 'playing') { canvas.setAttribute('tabindex', '0'); canvas.focus(); } window.addEventListener('keydown', handleKeyDown); console.log("Keydown listener attached"); }
                return () => { window.removeEventListener('keydown', handleKeyDown); console.log("Keydown listener removed"); }
            }, [gameState]); 

            useEffect(() => { /* ... kima kan ... */ 
                if (lives <= 0 && gameState === 'playing') { console.log("Game Over condition met"); setGameState('gameover'); }
            }, [lives, gameState]);

             useEffect(() => { /* ... kima kan ... */ 
                 console.log("Initial load: Loading round 1"); loadRoundData(1); 
             }, [loadRoundData]); 


            // --- Wallet/Payment Functions ---
             const handleConnectWallet = async () => { /* ... kima kan ... */ 
                setIsProcessing(true); setStatusMessage('1/3: Locating provider...'); console.log("Connecting...");
                try { const p = await getProvider(); if (!p) throw new Error('No provider. Use Farcaster client or wallet extension.'); setStatusMessage('2/3: Requesting accounts...'); console.log("Requesting accounts..."); const accs = await p.request({ method: 'eth_requestAccounts' }); if (accs && accs.length > 0) { const addr = accs[0]; setUserAddress(addr); console.log("Account:", addr); setStatusMessage('3/3: Getting user data...'); console.log("Getting user data..."); try { if (sdk && typeof sdk.getUserData === 'function') { const user = await sdk.getUserData(); if (user && user.fid) { setFid(user.fid); setStatusMessage(`✅ Connected! FID: ${user.fid}`); console.log("User:", user); } else { setFid(null); setStatusMessage(`✅ Connected: ${addr.slice(0,6)}...`); console.log("FID unavailable."); } } else { setFid(null); setStatusMessage(`✅ Connected: ${addr.slice(0,6)}...`); console.log("sdk.getUserData unavailable."); } } catch (fidErr) { setFid(null); setStatusMessage(`✅ Connected: ${addr.slice(0,6)}...`); console.warn("FID error:", fidErr); } } else throw new Error('No accounts returned.'); } catch (e) { console.error('Connect error:', e); setUserAddress(null); setFid(null); setStatusMessage(`❌ Error: ${e.message}`); } setIsProcessing(false);
             };
             const handlePayAndStart = async () => { /* ... kima kan ... */ 
                if (!userAddress) { setStatusMessage('Please connect wallet first.'); return; } if (DEVELOPER_WALLET === '0xYourWalletAddressHere' || !DEVELOPER_WALLET.startsWith('0x')) { setStatusMessage('⚠️ Dev: Set valid wallet address!'); return; } setIsProcessing(true); setStatusMessage('1/3: Locating provider...'); console.log("Starting Match...");
                try { const p = await getProvider(); if (!p) throw new Error('No provider.'); setStatusMessage('2/3: Sending payment...'); console.log("Sending payment..."); const h = await p.request({ method: 'eth_sendTransaction', params: [{ from: userAddress, to: DEVELOPER_WALLET, value: parseEther(GAME_FEE_ETH) }] }); setStatusMessage('✅ Payment complete! Starting Round 1...'); console.log("TX Hash:", h); setScore(0); setLives(MAX_LIVES); loadRoundData(1); setTimeout(() => { setGameState('playing'); setIsProcessing(false); setStatusMessage(''); if(canvasRef.current) canvasRef.current.focus(); }, 1000); } catch (e) { console.error('Start error:', e); setStatusMessage(`❌ Failed: ${e.message.split('.')[0]}.`); setIsProcessing(false); }
             };
             const handleNextRound = () => { /* ... kima kan ... */ 
                  console.log(`Starting round: ${currentRound + 1}`); loadRoundData(currentRound + 1); setGameState('playing'); if(canvasRef.current) canvasRef.current.focus(); 
             };


            // --- UI Rendering ---
            if (gameState === 'home') { /* ... kima kan ... */ 
                const isWalletConnected = !!userAddress;
                 return createElement('div', { className: "min-h-screen flex flex-col items-center justify-center p-4 text-center relative home-overlay", style: { backgroundImage: `url('image_e58548.png')`, backgroundSize: 'cover', backgroundPosition: 'center', backgroundRepeat: 'no-repeat' } }, 
                    createElement('div', {className: "home-content w-full max-w-xs"}, 
                        createElement('h1', { className: "text-5xl font-bold arcade-header tracking-tight mb-4" }, "Pixel Muncher"),
                        createElement('h2', { className: "text-xl text-cyan-300 mb-8" }, ""), 
                        createElement('div', { className: "flex flex-col gap-4 w-full" },
                            createElement('button', { onClick: handleConnectWallet, disabled: isProcessing || isWalletConnected, className: "secondary-button w-full disabled:opacity-50 disabled:cursor-not-allowed" }, isWalletConnected ? `✅ Connected: ${userAddress.slice(0,6)}...` : 'Connect Wallet'),
                            createElement('button', { onClick: handlePayAndStart, disabled: !isWalletConnected || isProcessing, className: "primary-button w-full disabled:opacity-50 disabled:cursor-not-allowed" }, isProcessing ? statusMessage : `Pay ${GAME_FEE_ETH} ETH & Play`),
                        ),
                        statusMessage && !isProcessing && createElement('div', { className: `mt-6 p-3 rounded-lg font-semibold text-sm w-full ${ statusMessage.includes('Error') || statusMessage.includes('failed') || statusMessage.includes('⚠️') || statusMessage.includes('❌') ? 'bg-red-500/80' : statusMessage.includes('✅') ? 'bg-green-500/80' : 'bg-blue-500/80'}` }, statusMessage)
                    ) 
                 );
            }

            if (gameState === 'round_won') { /* ... kima kan ... */ 
                 return createElement('div', { id:"roundWonModal", className: "modal", style: { display: 'flex' } }, 
                     createElement('div', { className: "modal-content" },
                         createElement('h2', { className: "text-3xl font-bold mb-4 text-green-400" }, `Round ${currentRound} Complete!`),
                         createElement('p', { className: "text-lg mb-6" }, `Current Score: ${score}`),
                         createElement('button', { id:"nextRoundButton", onClick: handleNextRound, className: "secondary-button w-full" }, `Start Round ${currentRound + 1}`)
                     )
                 );
            }

            if (gameState === 'gameover' || gameState === 'gamewon') { /* ... kima kan ... */ 
                 return createElement('div', { id:"gameEndModal", className: "modal", style: { display: 'flex' } }, 
                     createElement('div', { className: "modal-content" },
                         createElement('h2', { id: "modalTitle", className: "text-3xl font-bold mb-4" }, gameState === 'gamewon' ? '🎉 You Won the Match! 🎉' : 'Game Over!'),
                         createElement('p', { id:"modalScore", className: "text-lg mb-6" }, `Final Score: ${score}`),
                         createElement('button', { id:"restartButton", onClick: handlePayAndStart, disabled: isProcessing, className: "primary-button w-full" }, isProcessing ? statusMessage : `Pay ${GAME_FEE_ETH} ETH & Play Again`)
                     )
                 );
            }

            // Playing State UI 
            return createElement('div', { className: "flex flex-col items-center w-full max-w-[420px]" }, 
                createElement('header', { className: "text-center mb-2" },
                   createElement('h1', { className: "text-3xl font-bold arcade-header tracking-tight" }, "Pixel Muncher")
                ),
                createElement('div', { className: "flex justify-between w-full text-lg mb-2 px-1" },
                    createElement('div', { className: "font-semibold" }, 'Score: ', createElement('span', { id: "score", className: "text-yellow-400" }, score)),
                    createElement('div', { className: "font-semibold" }, 'Round: ', createElement('span', { id: "round", className: "text-green-400" }, currentRound)), 
                    createElement('div', { className: "font-semibold" }, 'Lives: ', createElement('span', { id: "lives", className: "text-red-500" }, lives))
                ),
                 createElement('canvas', { ref: canvasRef, id: "gameCanvas", width: mapWidth * gridSize, height: mapHeight * gridSize }),
                createElement('div', { className: "mt-3 text-center text-sm text-gray-400" },
                  createElement('p', null, 'Use ', createElement('span', {className: "text-yellow-400 font-bold"}, 'Arrow Keys'), ' to move.')
                )
             );
        }

        // ========= 5. Render App =========
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(createElement(App));

    </script>
</body>
</html>

